# 排序算法 总结

## 目标

1. 说出10种以上的排序算法, 并说明它们的原理
2. 10分钟内实现任意一种排序算法

## 比较

- 稳定排序
    - 可以保留数组中重复元素的相对位置

|              |  **时间复杂度**  | **是否为稳定排序** | **是否是原地排序** |备注|
| :----------: | :--------------: | :----------------: | :----------------: | :---:|
| **冒泡排序** |    **O(n^2)**    |       **√**        |       **√**        |		|
| **选择排序** |    **O(n^2)**    |       **×**        |       **√**        |		|
| **插入排序** |    **O(n^2)**    |       **√**        |       **√**        |		|
| **希尔排序** | **小于O(n^2)** |       **×**        |       **√**        |		|
| **归并排序** |   **O(nlogn)**   |       **√**        |       **×**        |		|
| **快速排序** |   **O(nlogn)**   |       **×**        |       **√**        |		|
|  **桶排序**  |     **O(n)**     |       **√**        |       **×**        |		|
| **计数排序** |     **O(n)**     |       **√**        |       **×**        |counting sort 适合于重复数字多的情况	|
| **基数排序** |     **O(n)**     |       **√**        |       **×**        |radix sort 按个位, 十位, 百位一个个排序	|
|  **堆排序**  |   **O(nlogn)**   |       **×**        |       **√**        |		|
|              |                  |                    |                    |		|


## 实测数据

测试3次10000个数据排序取平均, 大概感受下差距

```
insertAvgTime: 261.33ms
bubbleAvgTime: 672.67ms
selectionAvgTime: 481.33ms
shellAvgTime: 6.67ms
heapAvgTime: 7.67ms
quickAvgTime: 4.33ms
mergeAvgTime: 5.33ms
```

## 排序类问题归约

归约: 未解决某个问题而发明的算法正好可以用来解决另一种问题

### 找出重复元素

1. 排序加遍历
2. 对于范围确定的元素, 可以使用 计数排序(counting sort)
    - 例如 RelativeSortArray 这道题
3. 


### 排名

### 优先队列

### 中位数与顺序统计













