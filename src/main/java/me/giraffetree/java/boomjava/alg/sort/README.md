# 排序算法 总结

## 目标

1. 说出10种以上的排序算法, 并说明它们的原理
2. 10分钟内实现任意一种排序算法

## 比较

- 稳定排序
    - 可以保留数组中重复元素的相对位置

|              |  **时间复杂度**  | **是否为稳定排序** | **是否是原地排序** |备注|
| :----------: | :--------------: | :----------------: | :----------------: | :---:|
| **冒泡排序** |    **O(n^2)**    |       **√**        |       **√**        |		|
| **选择排序** |    **O(n^2)**    |       **×**        |       **√**        |		|
| **插入排序** |    **O(n^2)**    |       **√**        |       **√**        |		|
| **希尔排序** | **小于O(n^2)** |       **×**        |       **√**        |		|
| **归并排序** |   **O(nlogn)**   |       **√**        |       **×**        |		|
| **快速排序** |   **O(nlogn)**   |       **×**        |       **√**        |		|
|  **桶排序**  |     **O(n)**     |       **√**        |       **×**        |		|
| **计数排序** |     **O(n)**     |       **√**        |       **×**        |counting sort 适合于重复数字多的情况	|
| **基数排序** |     **O(n)**     |       **√**        |       **×**        |radix sort 按个位, 十位, 百位一个个排序	|
|  **堆排序**  |   **O(nlogn)**   |       **×**        |       **√**        |		|
|              |                  |                    |                    |		|


## 实测数据

测试3次10000个数据排序取平均, 大概感受下差距

```
insertAvgTime: 261.33ms
bubbleAvgTime: 672.67ms
selectionAvgTime: 481.33ms
shellAvgTime: 6.67ms
heapAvgTime: 7.67ms
quickAvgTime: 4.33ms
mergeAvgTime: 5.33ms
```

## 排序类问题归约

归约: 未解决某个问题而发明的算法正好可以用来解决另一种问题

### 找出重复元素

1. 排序加遍历
2. 对于范围确定的元素, 可以使用 计数排序(counting sort)
    - 例如 RelativeSortArray 这道题
3. 


### 排名

### 优先队列

### 中位数与顺序统计

### top-K 问题

- 快速排序的平均复杂度为 O(nlogn) ，但最坏时间复杂度为 O(n^2)。
- 堆
    - 时间复杂度 O(nlog(k))
- [BFPRT算法原理](https://zhuanlan.zhihu.com/p/31498036)
    - 又称为中位数的中位数算法，它的最坏时间复杂度为 O(n) ，它是由Blum、Floyd、Pratt、Rivest、Tarjan提出。
    - 该算法的思想是修改快速选择算法的主元选取方法，提高算法在最坏情况下的时间复杂度
    - 步骤 来自: https://www.cnblogs.com/wade-luffy/p/7777313.html
        - 将n个元素每 5 个一组，分成n/5(上界)组。
        - 取出每一组的中位数，任意排序方法，比如插入排序。
        - 递归的调用 selection 算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。
        - 用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。
        - 若i==k，返回x；若i<k，在小于x的元素中递归查找第i小的元素；若i>k，在大于x的元素中递归查找第i-k 小的元素。










